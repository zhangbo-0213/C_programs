### C++关于C的增强

- **namespace的引入**      
namespace的引入将全局作用域进行了划分，同名的全局变量所属于不同的命名空间内不会引起冲突        
命名空间内可以相互嵌套     
```c++    
    namespace namespaceB {
        int b=20;
        namespace namespaceC{
            struct student{
                char name[10];
                int age;
                };
            }
    }
```

- **实用性增强**        
C++内可以在变量使用前声明，无需像C语言中，要声明在文件的开头       

- **regiser关键字增强**         
 1. C++中的寄存器变量可以取到其地址      
 2. C++针对寄存器变量做了自身的优化，例如 for 循环中的频繁使用的临时计数变量 i ,C++将其作为寄存器变量，以提高运行效率         
 
 - **类型检测加强**     
 C语言中，重复声明同名的变量是合法的，同名的变量最终会被分配到内存的同一块地址中      
 C++不允许重复声明同名的变量 
 C++中对函数的参数，返回值类型检测更加严格
 
 - "struct关键字增强"      
 C语言中，结构体不认为是一种新的数据类型，因此在变量声明时 需要加 struct 关键字       
 C++中，结构体被看作是新的数据类型，变量的声明不必加 struct 关键字，与用class关键字声明的类型使用一致    
 
 - **新增 bool 类型**    
 C++中 一个 bool 类型理论占用1个字节大小     
 多个 bool  类型变量定义在一起，可能每个只占用一个 bit, 取决编译器的实现     
 
 - **三目运算符增强**    
 C++中对 a<b?a:b=30; 做了增强，使三目运算符返回参与运算的变量本身，从而可以在赋值的左边      
 C语言中，三目运算符返回的是值，因此不能出现在赋值左边   
 C语言中，实现C++的三目运算符左值效果:    *(a<b?&a:&b )=30;   
   
- **const 关键字增强**         
C中 const 关键字所修饰的变量，并非真正的常量，而是常变量，通过指针可以修改其指向的内存地址中的值       
C++中，const  定义的是真正的常量，关键字所修饰的常量会被存储在一个符号表中，使用该变量时，会从符号表中进行直接替换，如果使用&取值符，C++编译器会为常量分配内存空间（在编译期间分配内存），关于 const 修饰参数和函数总结 [C++ const关键字的总结](https://blog.csdn.net/u011333734/article/details/81294043#commentBox)   

- **引用的引入**      
程序通过变量来申请并命名内存空间         
程序中变量名是一段连续内存地址空间的别名       
通过变量名来访问其对应的内存地址空间内容                
**引用**是C++中引入的新内容，可以看作是已命名变量的别名          

```c++    
//引用语法 Type & name=var;
int a=10;
//普通引用必须要做初始化
int &b=a;    

//引用做函数参数时，不必初始化
void swap02(int &a,int &b){
int c=a;
a=b;
b=c;
}
```      
引用的实质是一个**常量指针**     Type & name <=> Type * const name ;                   
在使用引用进行赋值时， int c=p;   // 实质 c=*p ;       
当函数返回值为 引用类型的变量（栈空间内的变量要注意自动被释放的问题），函数可以直接作为左值被赋值，因为返回的是引用，实际指向某一内存空间            
由于引用实际上返回的是对象本身，除了可以做左值外，同时还可以实现链式编程，如：      

```c++ 
cout<<""<<""<<""endl;    
```
常引用       
常引用的初始化分两种情况：      
1.使用变量初始化     
```c++
int val=20;   
```
使用变量初始化常引用，使得引用所指内容为只读，即不能通过 常引用去改变 变量的值       
```c++
const int &r_val=val;      
```
使用常引用去改变变量的值，编译不通过      
```c++
//r_val=30;    
```
但是可以通过变量自身去改变 其值，引用的本质只是记录了该变量的内存地址        
```c++
val=30;       
```     
2.使用常值（字面量）初始化         
直接使用字面量去初始化 对应类型的引用 是无法通过的，由于字面量，系统并为为其分配内存，因此初始化引用，无法拿到地址          
在类型前加上 const 常量在取地址时，会为其分配内存空间         
```c++    
const int &r_val1=43;      
```    
由于引用的本质是 常指针，即所指的地址不能被改变，而常引用使所指的内存空间的内容不能被改变，因此常引用在做函数的参数时，可以使传递进来的参数的地址和地址中的内容都不能被改变    


 


 
